{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"glaucus Wiki Welcome to glaucus Wiki! The wiki is still under heavy development.","title":"Home"},{"location":"#glaucus-wiki","text":"Welcome to glaucus Wiki! The wiki is still under heavy development.","title":"glaucus Wiki"},{"location":"convention/","text":"Naming Convention Glaucus bennettae With full credits, Copyright \u00a92003-2019 Gary Cobb, http://nudibranch.com.au Named after the smallest (and most venemous) sea slug in the world Glaucus bennettae , glaucus is an independent, open-source, general-purpose, bleeding-edge, rolling-release, source-based Linux\u00ae distribution based on musl libc and toybox, built from scratch around the suckless philosophy without sacrificing convenience. Just like the animal, glaucus has the following: ceras A single package cerata Multiple packages cluster A single group of packages clusters Multiple groups of packages cyst A single package dependency cysts Multiple package dependencies envenomate The build script species The different available flavors/versions of glaucus atlanticus The main version of glaucus available, built with the most extreme performance optimization flags available and consists only of packages required to get a sway WM to work (a wayland only distribution or with minimal Xorg cerata required to get sway to work). bennettae The smallest version of glaucus available, built with the most extreme size optimization flags available and consists only of packages required to get it to boot (should be under 10 MB in size). thompsoni Will be kept as a secret for now. albino A libre version of glaucus atlanticus that hasn't been tainted with proprietary software (there exists a white albino non-pigmented glaucus atlanticus, see the image below): With full credits, Copyright \u00a92009-2019 Orellana, E.R., http://www.seaslugforum.net fleet Distributions based on glaucus combined genus A single project forked from glaucus genera Multiple projects forked from glaucus radula The package manager sac A single directory that holds the build result of a single ceras sacs Multiple directories that hold the build result of multiple cerata venom A single directory that contains the final xz tarball of a sac along with a checksum file that hashes its contents, both of which are obtained after running envenomate . voyager A glaucus tester or a ceras maintainer voyagers Multiple glaucus testers of multiple cerata maintainers TODO A custom screenfetch-like command that shows an ASCII image of the animal with X number of cerata (with X being the actual number of cerata installed in glaucus, meaning that the ASCII image changes whenever a cerata is added/removed) is in the TODO list for enthusiasts' bragging rights.","title":"Naming Convention"},{"location":"convention/#naming-convention","text":"Glaucus bennettae With full credits, Copyright \u00a92003-2019 Gary Cobb, http://nudibranch.com.au Named after the smallest (and most venemous) sea slug in the world Glaucus bennettae , glaucus is an independent, open-source, general-purpose, bleeding-edge, rolling-release, source-based Linux\u00ae distribution based on musl libc and toybox, built from scratch around the suckless philosophy without sacrificing convenience. Just like the animal, glaucus has the following:","title":"Naming Convention"},{"location":"convention/#ceras","text":"A single package","title":"ceras"},{"location":"convention/#cerata","text":"Multiple packages","title":"cerata"},{"location":"convention/#cluster","text":"A single group of packages","title":"cluster"},{"location":"convention/#clusters","text":"Multiple groups of packages","title":"clusters"},{"location":"convention/#cyst","text":"A single package dependency","title":"cyst"},{"location":"convention/#cysts","text":"Multiple package dependencies","title":"cysts"},{"location":"convention/#envenomate","text":"The build script","title":"envenomate"},{"location":"convention/#species","text":"The different available flavors/versions of glaucus","title":"species"},{"location":"convention/#atlanticus","text":"The main version of glaucus available, built with the most extreme performance optimization flags available and consists only of packages required to get a sway WM to work (a wayland only distribution or with minimal Xorg cerata required to get sway to work).","title":"atlanticus"},{"location":"convention/#bennettae","text":"The smallest version of glaucus available, built with the most extreme size optimization flags available and consists only of packages required to get it to boot (should be under 10 MB in size).","title":"bennettae"},{"location":"convention/#thompsoni","text":"Will be kept as a secret for now.","title":"thompsoni"},{"location":"convention/#albino","text":"A libre version of glaucus atlanticus that hasn't been tainted with proprietary software (there exists a white albino non-pigmented glaucus atlanticus, see the image below): With full credits, Copyright \u00a92009-2019 Orellana, E.R., http://www.seaslugforum.net","title":"albino"},{"location":"convention/#fleet","text":"Distributions based on glaucus combined","title":"fleet"},{"location":"convention/#genus","text":"A single project forked from glaucus","title":"genus"},{"location":"convention/#genera","text":"Multiple projects forked from glaucus","title":"genera"},{"location":"convention/#radula","text":"The package manager","title":"radula"},{"location":"convention/#sac","text":"A single directory that holds the build result of a single ceras","title":"sac"},{"location":"convention/#sacs","text":"Multiple directories that hold the build result of multiple cerata","title":"sacs"},{"location":"convention/#venom","text":"A single directory that contains the final xz tarball of a sac along with a checksum file that hashes its contents, both of which are obtained after running envenomate .","title":"venom"},{"location":"convention/#voyager","text":"A glaucus tester or a ceras maintainer","title":"voyager"},{"location":"convention/#voyagers","text":"Multiple glaucus testers of multiple cerata maintainers","title":"voyagers"},{"location":"convention/#todo","text":"A custom screenfetch-like command that shows an ASCII image of the animal with X number of cerata (with X being the actual number of cerata installed in glaucus, meaning that the ASCII image changes whenever a cerata is added/removed) is in the TODO list for enthusiasts' bragging rights.","title":"TODO"},{"location":"history/","text":"History glaucus initially started out as a hobby project called snail, and has thus been under development for 2 years now. Aim The aim was to create an extremely minimal Linux based operating system that would run on modern hardware and require less than or equal to 1MB of RAM to run. Experimentation Experimentation started with the lightest possible alternatives to the current tools used in creating cross-compilation toolchains. The initial stage of trial and error took around 8 months. Every possible toolchain combination with compilers ranging from tcc , scc , pcc and gcc to binary utilities ranging from elfutils , elftoolchain and binutils to standard C libraries ranging from uClibc , uClibc-ng , dietlibc and musl . The initial goal was to test each combination, and attempt a complete build of all suckless sbase tools followed by libressl. A good amount of time was spent on constructing different toolchains using various components other than GNU. The first toolchains used tcc and elfutils/elftoolchain but failed to build a complete sbase... The second generation of toolchains used pcc and elfutils/elftoolchain, and they were much better, as they were able to compile all sbase tools but optimization was really lacking, as the binaries that resulted from gcc -Os were smaller than those from pcc -Os. Then elfutils/elftoolchain were ditched completely as they don't work well with musl and neither includes all utilities offered by binutils (so you'll end up with a mixture of both trying to cover up the basic utilities offered by binutils); hence, the choice to stick with gcc and binutils was made. tcc was really fast but failed to build all suckless sbase tools and libressl and thus failed the test. pcc was a close contender as it passed the test successfully, but the resulting binaries were noticeably bigger than gcc 's even at the same optimization level. As for the binary utilities, I ditched elftoolchain in favor of elfutils because the project wasn't as active, but then found out that elfutils doesn't work well with gcc ; hence, binutils was the only option left. I didn't try LLVM as I was trying to limit the amount of cerata using c++, but I tested libc++ once and libstdc++ was faster (due to regressions in libc++). I didn't try lld yet, as I was interested in gold but, I went back to bfd/ld after I knew that gold doesn't build with musl unless PIE is enabled (I didn't plan on using PIE early on, but I'm considering it in the near future). I might try lld in the distant future and maybe give GOLD another chance, but I won't be changing the design of the toolchain, especially after I got it working with the optimizations I'm using. One year later, the goal was accomplished. snail booted successfully and ran in under 1MB of RAM. However, snail was extreme, it used an extremely minimal kernel configuration (based on DOTSLASHLINUX kernel configuration guides) and dash as its sole shell, suckless sbase and ubase for userland and sinit/svc as an init system/service manager respectively. The root filesystem was also read-only. glaucus glaucus is an attempt to fix snail and turn it into a usable distribution that's not only extremely lightweight, but also highly optimized for performance and much more convenient.","title":"History"},{"location":"history/#history","text":"glaucus initially started out as a hobby project called snail, and has thus been under development for 2 years now.","title":"History"},{"location":"history/#aim","text":"The aim was to create an extremely minimal Linux based operating system that would run on modern hardware and require less than or equal to 1MB of RAM to run.","title":"Aim"},{"location":"history/#experimentation","text":"Experimentation started with the lightest possible alternatives to the current tools used in creating cross-compilation toolchains. The initial stage of trial and error took around 8 months. Every possible toolchain combination with compilers ranging from tcc , scc , pcc and gcc to binary utilities ranging from elfutils , elftoolchain and binutils to standard C libraries ranging from uClibc , uClibc-ng , dietlibc and musl . The initial goal was to test each combination, and attempt a complete build of all suckless sbase tools followed by libressl. A good amount of time was spent on constructing different toolchains using various components other than GNU. The first toolchains used tcc and elfutils/elftoolchain but failed to build a complete sbase... The second generation of toolchains used pcc and elfutils/elftoolchain, and they were much better, as they were able to compile all sbase tools but optimization was really lacking, as the binaries that resulted from gcc -Os were smaller than those from pcc -Os. Then elfutils/elftoolchain were ditched completely as they don't work well with musl and neither includes all utilities offered by binutils (so you'll end up with a mixture of both trying to cover up the basic utilities offered by binutils); hence, the choice to stick with gcc and binutils was made. tcc was really fast but failed to build all suckless sbase tools and libressl and thus failed the test. pcc was a close contender as it passed the test successfully, but the resulting binaries were noticeably bigger than gcc 's even at the same optimization level. As for the binary utilities, I ditched elftoolchain in favor of elfutils because the project wasn't as active, but then found out that elfutils doesn't work well with gcc ; hence, binutils was the only option left. I didn't try LLVM as I was trying to limit the amount of cerata using c++, but I tested libc++ once and libstdc++ was faster (due to regressions in libc++). I didn't try lld yet, as I was interested in gold but, I went back to bfd/ld after I knew that gold doesn't build with musl unless PIE is enabled (I didn't plan on using PIE early on, but I'm considering it in the near future). I might try lld in the distant future and maybe give GOLD another chance, but I won't be changing the design of the toolchain, especially after I got it working with the optimizations I'm using. One year later, the goal was accomplished. snail booted successfully and ran in under 1MB of RAM. However, snail was extreme, it used an extremely minimal kernel configuration (based on DOTSLASHLINUX kernel configuration guides) and dash as its sole shell, suckless sbase and ubase for userland and sinit/svc as an init system/service manager respectively. The root filesystem was also read-only.","title":"Experimentation"},{"location":"history/#glaucus","text":"glaucus is an attempt to fix snail and turn it into a usable distribution that's not only extremely lightweight, but also highly optimized for performance and much more convenient.","title":"glaucus"},{"location":"install/","text":"Install (Outdated) 0. Create the glaucus user and group Run the following commands as root (you can skip the first command if /etc/login.def contains USERGROUPS_ENAB yes which is the default behaviour): groupadd glaucus useradd -g glaucus -k /dev/null -ms /bin/bash glaucus Now, also as root, give the newly created glaucus user a password and confirm it: passwd glaucus Next login as glaucus : su - glaucus 1. Clone the glaucus repository Make sure that you're in glaucus's user home directory /home/glaucus as that's where glaucus will be built: cd /home/glaucus Pick any of the following mirrors: * GitHub * GitLab * NotABug * BitBucket * Framagit * SourceForge And clone it into your existing (currently empty) working directory /home/glaucus : git clone https://github.com/glaucuslinux/glaucus . 2. Logout and log back in In order for the .bash_profile and .bashrc files to take effect, you need to first logout: exit Then log back in: su - glaucus 3. Initialize the glaucus repository Before you can commence constructing glaucus, you need to initialize the glaucus repository that you've cloned in order to populate it with required directories: cd /home/glaucus dash /home/glaucus/scripts/initialize.sh 5. Constructing the toolchain cd /home/glaucus time dash /home/glaucus/scripts/toolchain/run.sh 6. Constructing the chroot environment cd /home/glaucus time dash /home/glaucus/scripts/chroot/run.sh 7. Construct and envenomate the final system cd / time dash /scripts/system/run.sh 8. Logout exit 8. Create a bootable image cd /home/glaucus time dash /home/glaucus/scripts/system/img.sh","title":"Install"},{"location":"install/#install-outdated","text":"","title":"Install (Outdated)"},{"location":"install/#0-create-the-glaucus-user-and-group","text":"Run the following commands as root (you can skip the first command if /etc/login.def contains USERGROUPS_ENAB yes which is the default behaviour): groupadd glaucus useradd -g glaucus -k /dev/null -ms /bin/bash glaucus Now, also as root, give the newly created glaucus user a password and confirm it: passwd glaucus Next login as glaucus : su - glaucus","title":"0. Create the glaucus user and group"},{"location":"install/#1-clone-the-glaucus-repository","text":"Make sure that you're in glaucus's user home directory /home/glaucus as that's where glaucus will be built: cd /home/glaucus Pick any of the following mirrors: * GitHub * GitLab * NotABug * BitBucket * Framagit * SourceForge And clone it into your existing (currently empty) working directory /home/glaucus : git clone https://github.com/glaucuslinux/glaucus .","title":"1. Clone the glaucus repository"},{"location":"install/#2-logout-and-log-back-in","text":"In order for the .bash_profile and .bashrc files to take effect, you need to first logout: exit Then log back in: su - glaucus","title":"2. Logout and log back in"},{"location":"install/#3-initialize-the-glaucus-repository","text":"Before you can commence constructing glaucus, you need to initialize the glaucus repository that you've cloned in order to populate it with required directories: cd /home/glaucus dash /home/glaucus/scripts/initialize.sh","title":"3. Initialize the glaucus repository"},{"location":"install/#5-constructing-the-toolchain","text":"cd /home/glaucus time dash /home/glaucus/scripts/toolchain/run.sh","title":"5. Constructing the toolchain"},{"location":"install/#6-constructing-the-chroot-environment","text":"cd /home/glaucus time dash /home/glaucus/scripts/chroot/run.sh","title":"6. Constructing the chroot environment"},{"location":"install/#7-construct-and-envenomate-the-final-system","text":"cd / time dash /scripts/system/run.sh","title":"7. Construct and envenomate the final system"},{"location":"install/#8-logout","text":"exit","title":"8. Logout"},{"location":"install/#8-create-a-bootable-image","text":"cd /home/glaucus time dash /home/glaucus/scripts/system/img.sh","title":"8. Create a bootable image"},{"location":"qemu/","text":"QEMU (Outdated) Although glaucus is intended to be run natively on any x86-64 machine, it's still in under heavy development and only runs under QEMU for now. The commands here are only to get the img files up and running (meaning that it still needs more research on how to get the best performance with QEMU, while staying extremely lightweight. Relevant QEMU flags also need to be investigated). Binary glaucus If you've already downloaded one of (currently) two provided glaucus img files, then all you need to do is: login as your normal regular user (you know the one you're using to login your display manager or login manager, the one that has access to X, DISPLAY, GUI...) Make sure qemu is installed and run the following: if you've downloaded the glaucus core: qemu-system-x86_64 \\ -enable-kvm \\ -hda glaucus-core-x86_64-31082019.img Or the following if you've downloaded glaucus extra: qemu-system-x86_64 \\ -enable-kvm \\ -hda glaucus-extra-x86_64-01092019.img Type in root as the user and leave the password empty and press enter and you should be in! Source glaucus After having built glaucus with -march=native in scripts/Variables run the following: Login as your normal regular user (you know the one you're using to login your display manager or login manager, the one that has access to X, DISPLAY, GUI...) Run the following (don't forget to add -cpu host or you'll get a kernel panic): qemu-system-x86_64 \\ -enable-kvm \\ -cpu host \\ -hda glaucus.img TODO Leverage the use of QXL Improve virtualization with QEMU","title":"QEMU"},{"location":"qemu/#qemu-outdated","text":"Although glaucus is intended to be run natively on any x86-64 machine, it's still in under heavy development and only runs under QEMU for now. The commands here are only to get the img files up and running (meaning that it still needs more research on how to get the best performance with QEMU, while staying extremely lightweight. Relevant QEMU flags also need to be investigated).","title":"QEMU (Outdated)"},{"location":"qemu/#binary-glaucus-if-youve-already-downloaded-one-of-currently-two-provided","text":"glaucus img files, then all you need to do is: login as your normal regular user (you know the one you're using to login your display manager or login manager, the one that has access to X, DISPLAY, GUI...) Make sure qemu is installed and run the following: if you've downloaded the glaucus core: qemu-system-x86_64 \\ -enable-kvm \\ -hda glaucus-core-x86_64-31082019.img Or the following if you've downloaded glaucus extra: qemu-system-x86_64 \\ -enable-kvm \\ -hda glaucus-extra-x86_64-01092019.img Type in root as the user and leave the password empty and press enter and you should be in!","title":"Binary glaucus If you've already downloaded one of (currently) two provided"},{"location":"qemu/#source-glaucus","text":"After having built glaucus with -march=native in scripts/Variables run the following: Login as your normal regular user (you know the one you're using to login your display manager or login manager, the one that has access to X, DISPLAY, GUI...) Run the following (don't forget to add -cpu host or you'll get a kernel panic): qemu-system-x86_64 \\ -enable-kvm \\ -cpu host \\ -hda glaucus.img","title":"Source glaucus"},{"location":"qemu/#todo","text":"Leverage the use of QXL Improve virtualization with QEMU","title":"TODO"},{"location":"todo/","text":"TODO Replace musl malloc with Jemalloc (always without relying on environment variable) Fix jemalloc segfault (at ip) Disable/Enable stuff that are auto detected Create a bootable image capable of building itself from source Apply K&R (tabs = 2 spaces) shell syntax styles Check licenses and dependencies Switch back to -march=x86-64 for release of cerata on github Fill in the README files for all cerata Give approximate time needed to compile each package based on my CPU Add conflicts to radula Add dependency resolution using tsort to radula Create a variables file for building Xorg.... to get all packages reading its variables Fix graphics and start SwayWM Remove -e from single expression seds Disable Libdatrie and libthai support from pango and see if it works Harden the toolchain and executables (SSP and PIE) gcompat for running glibc executables on musl","title":"TODO"},{"location":"todo/#todo","text":"Replace musl malloc with Jemalloc (always without relying on environment variable) Fix jemalloc segfault (at ip) Disable/Enable stuff that are auto detected Create a bootable image capable of building itself from source Apply K&R (tabs = 2 spaces) shell syntax styles Check licenses and dependencies Switch back to -march=x86-64 for release of cerata on github Fill in the README files for all cerata Give approximate time needed to compile each package based on my CPU Add conflicts to radula Add dependency resolution using tsort to radula Create a variables file for building Xorg.... to get all packages reading its variables Fix graphics and start SwayWM Remove -e from single expression seds Disable Libdatrie and libthai support from pango and see if it works Harden the toolchain and executables (SSP and PIE) gcompat for running glibc executables on musl","title":"TODO"}]}